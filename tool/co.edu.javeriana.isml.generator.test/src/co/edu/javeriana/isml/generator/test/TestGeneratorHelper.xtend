package co.edu.javeriana.isml.generator.test

import co.edu.javeriana.isml.generator.common.SimpleTemplate
import org.eclipse.emf.ecore.EObject

import static org.junit.Assert.*

// Probar con EntityGenerator
class TestGeneratorHelper {

	/**
	 * Verifies whether a templates generates the expected output code from a given input model element. Both the 
	 * generated code and the expected output code strings are processed to remove excess whitespaces and to
	 * add spaces both before and after any non alphabetic character. This should facilitate comparison between expected output
	 * and generated code, since the programmer does not have to worry about whitespaces.
	 * To force a 1-to-1 comparison, utilize the method {@link TestGeneratorHelper#assertGeneratesVerbatim}
	 * @param template The template
	 * @param input The input model element. This element is fed to the template to generate code
	 * @param expectedOutput The expected code to be generated by the template
	 */
	def <T extends EObject> void assertGenerates(SimpleTemplate<T> template, T input, CharSequence expectedOutput) {
		val generatedText = template.toText(input)
		val trimmedGeneratedText = generatedText.trimUnwantedChars
		val trimmedExpectedOutput = expectedOutput.trimUnwantedChars
		compare(trimmedGeneratedText, trimmedExpectedOutput, expectedOutput)
	}

	/**
	 * Verifies whether a templates generates the expected output code from a given input model element. The expected
	 * output must be <b>exactly</b> the same as the generated code, otherwise the assertion fails.
	 * @param template The template
	 * @param input The input model element. This element is fed to the template to generate code
	 * @param expectedOutput The expected code to be generated by the template
	 */
	def <T extends EObject> void assertGeneratesVerbatim(SimpleTemplate<T> template, T input, CharSequence expectedOutput) {
		val generatedText = template.toText(input)
		val trimmedGeneratedText = generatedText.trimUnwantedChars
		val trimmedExpectedOutput = expectedOutput.trimUnwantedChars
		compare(trimmedGeneratedText, trimmedExpectedOutput, expectedOutput)
	}

	def compare(String trimmedGeneratedText, String trimmedExpectedOutput, CharSequence expectedOutput) {
		if (!trimmedGeneratedText.equals(trimmedExpectedOutput)) {
			printCallingMethod()
			println("\nExpected output:\n\"" + trimmedExpectedOutput + "\"")
			println("Generated code: \n\"" + trimmedGeneratedText + "\"")
			val diffPos = findDiffPos(trimmedExpectedOutput, trimmedGeneratedText)
			val expectedPortion = trimmedExpectedOutput.getSurroundingString(diffPos)
			val generatedPortion = trimmedGeneratedText.getSurroundingString(diffPos)
			
			println("\nThe difference is at position " + diffPos)
			println(expectedPortion)
			println(generatedPortion)
			
			fail("Incorrect generated text. Expected: \n" + expectedOutput + "\n\nbut got:\n" + trimmedGeneratedText)
		}
	}
	
	/**
	 * @returns the position where two strings are different, -1 if both are equal
	 */
	def findDiffPos(String string, String string2) {
		val length = Math.min(string.length, string2.length)
		var i=0
		while (i<length) {
			if (string.charAt(i) != string2.charAt(i)) {
				return i
			}
			i++
		}
		if (string.length != string2.length) {
			return i
		}
		return -1;
		
	}
	
	def getSurroundingString(String str, int pos) {
		val start = Math.max(pos-40,0)
		val end = Math.min(pos+40,str.length)
		return str.substring(start,end)
	}

	def printCallingMethod() {
		println(Thread.currentThread.stackTrace.get(2).methodName)
	}

	def trimUnwantedChars(CharSequence seq) {
		return String.valueOf(seq)//				.replaceAll("[,;|\\.\\*\\+\\-/]", " $0 ")
//				.replaceAll("[\\(\\)\\{\\}\\[\\]<>]", " $0 ")
		.replaceAll("[^A-Za-z]", " $0 ").replaceAll("\\s+", " ").trim

	}

}